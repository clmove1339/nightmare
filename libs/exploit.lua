require 'libs.enums';

exploit = {}; do
    local function pack(value, max)
        local list = {};

        if value ~= nil then
            for i = 1, max do
                list[i] = value;
            end;
        end;

        return list;
    end;

    local total = 0;
    local shifting = 0;
    local breaking = 0;

    local defensive =
    {
        tick = 0,
        duration = 0
    };

    local breaking_data = pack(0, 16);
    local shifting_data = pack(0, 16);

    function exploit:is_active()
        return total > 0;
    end;

    function exploit:is_shifting()
        return shifting > 0;
    end;

    function exploit:is_break_lagcomp()
        return breaking > 0;
    end;

    function exploit:get_defensive_data()
        return defensive;
    end;

    function exploit:on_net_update_start()
        local me = entitylist.get_local_player();

        if not (me and me:is_alive()) then
            return;
        end;

        local tick = globals.tick_count;
        local tickinterval = globals.interval_per_tick;

        local ptr = me:get_address();

        local m_flSimulationTime = ffi.cast('float*', ptr + 0x26C - 0x4)[0];
        local m_flOldSimulationTime = ffi.cast('float*', ptr + 0x26C)[0];
        local m_flMinSimulationTime = math.min(m_flOldSimulationTime, m_flSimulationTime);

        local diff = m_flOldSimulationTime - m_flSimulationTime;

        shifting = math.min(unpack(shifting_data));

        shifting_data[#shifting_data + 1] = tick - (m_flMinSimulationTime / tickinterval);
        breaking_data[#breaking_data + 1] = (diff / tickinterval);

        table.remove(shifting_data, 1);
        table.remove(breaking_data, 1);

        breaking = math.max(unpack(breaking_data));
        total = math.max(shifting, breaking);
    end;
end;

return exploit;
